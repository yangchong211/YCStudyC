## C++从0到1案例学习
#### 目录介绍
- 01.第一天：基础语法
- 02.第二天：运算符和表达式
- 03.第三天：判断和循环
- 04.第四天：数组和容器
- 05.第五天：指针和引用
- 06.第六天：函数实践
- 07.第七天：IO输入和输出
- 08.第八天：结构和类
- 09.第九天：继承和派生
- 10.第十天：多线程和并发
- 11.第十一天：线程安全锁
- 12.第十二天：内存分配堆和栈
- 13.第十三天：异常处理
- 14.第十四天：STL标准模板库
- 15.第十五天：设计模式
- 16.第十六天：程序调试
- 17.第十七天：网络通信
- 18.第十八天：综合案例



### 01.第一天：基础语法
#### 1.1 第一个C++程序
- 1.1 C++简单介绍
    - 1.1.1 面向对象程序设计，完全支持面向对象的程序设计，包括面向对象开发的四大特性：封装，继承，多台，抽象
    - 1.1.2 标准库，由3个部分组成。核心语言，c++标准库，标准模版库STL
    - 1.1.3 C++ 的使用场景，在许多行业和领域都有广泛应用，包括：游戏，嵌入式，图形图像等
- 1.2 C++基本语法
    - 1.2.1 基本语法介绍，主要看一下类，对象，方法，变量等
    - 1.2.2 C++ 程序结构，学习和练习hello world案例
    - 1.2.3 编译 & 执行 C++ 程序，如何把源代码保存在一个文件中，以及如何编译并运行它
    - 1.2.4 C++ 中的分号 & 语句块，分号是语句结束符。每个语句必须以分号结束。它表明一个逻辑实体的结束。
    - 1.2.5 标志符和关键字，保留字不能作为常量名、变量名或其他标识符名称。
    - 1.2.6 一些问题思考，把遇到的问题思考分析一下
- 1.3 C++ 注释
    - 1.3.1 C++ 注释分类，C++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。



#### 1.2 数据类型介绍
- 2.1 基本的内置类型
    - 2.1.1 bool，布尔类型
    - 2.1.2 char，字符型
    - 2.1.3 int，整型
    - 2.1.4 float，浮点型
    - 2.1.5 double，双浮点型
    - 2.1.6 void，无类型
    - 2.1.7 wchar_t，宽字符型
- 2.2 多类型修饰符
    - 2.2.1 signed，有符号类型是一种整数类型，可以表示正数、负数和零。有符号类型使用signed关键字进行声明。
    - 2.2.2 unsigned，无符号类型是一种整数类型，它只能表示非负整数值。无符号类型使用unsigned关键字进行声明。
    - 2.2.3 short，short是一种有符号短整数类型，通常为16位。
    - 2.2.4 long，有符号长整数类型，通常为32位或64位，范围取决于编译器和平台。
- 2.3 其他一些类型
    - 2.3.1 size_t，是一种无符号整数类型，用于表示对象的大小或数组的索引。它是C++标准库中定义的类型，通常用于表示内存大小、数组长度和对象的大小。
    - 2.3.2 uint8_t，uint8_t是一种固定宽度的无符号整数类型，用于表示8位（1字节）的无符号整数值。
    - 2.3.3 enum，枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。
- 2.4 typedef 声明
    - 2.4.1 typedef声明，使用 typedef 为一个已有的类型取一个新的名字。
- 2.5 类型转换
    - 2.5.1 静态转换（Static Cast），static_cast静态转换是将一种数据类型的值强制转换为另一种数据类型的值。
    - 2.5.2 动态转换（Dynamic Cast），dynamic_cast动态转换通常用于将一个基类指针或引用转换为派生类指针或引用。
    - 2.5.3 常量转换（Const Cast），const_cast常量转换用于将 const 类型的对象转换为非 const 类型的对象。
    - 2.5.4 重新解释转换（Reinterpret Cast），reinterpret_cast重新解释转换将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换。
- 2.8 做一些练习
    - 2.8.1 将char转化为uint8_t，由于char类型可以是有符号或无符号的，转换为uint8_t类型可以确保将其视为无符号8位整数。
    - 2.8.2 将string转化为uint8_t，将std::string转换为uint8_t类型需要进行逐个字符的转换。

  

#### 1.3 变量和常量
- 3.1 变量类型
    - 3.1.1 变量类型介绍，多种变量类型可用于存储不同种类的数据。基本数据类型，也允许定义比如枚举、指针、数组、引用、数据结构、类等等
    - 3.1.2 C++中的变量定义，变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。
    - 3.1.3 C++中的变量声明，变量声明向编译器保证变量以给定的类型和名称存在
    - 3.1.4 C++中左值和右值，左值可以出现在赋值号的左边或右边。右值是不能对其进行赋值的表达式
- 3.2 变量作用域
    - 3.2.1 作用域介绍，一般来说有三个地方可以定义变量，作用域是程序的一个区域，变量的作用域可以分为4种
    - 3.2.2 局部变量，在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。
    - 3.2.3 全局变量，在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。
    - 3.2.4 类作用域，在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。类作用域变量的生命周期与类的生命周期相同。
    - 3.2.5 块作用域，在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。
- 3.3 常量
    - 3.3.1 整数常量，整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。
    - 3.3.2 浮点常量，浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。
    - 3.3.3 布尔常量，布尔常量共有两个，它们都是标准的 C++ 关键字：true 值代表真。 false 值代表假。
    - 3.3.4 字符常量，字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L'x'）
    - 3.3.5 字符串常量，字符串字面值或常量是括在双引号 "" 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。
    - 3.3.6 定义常量，在 C++ 中，有两种简单的定义常量的方式：使用 #define 预处理器。使用 const 关键字。


#### 1.4 修饰符和标识符


#### 1.5 字符串
- 1.5.1 字符串介绍和使用
    - 1.5.1.1 C 风格字符串，C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 null 字符 \0 终止的一维字符数组。
    - 1.5.1.2 函数处理字符串，C++ 中有大量的函数用来操作以 null 结尾的字符串，strcpy复制，strlen返回长度，strcmp比较是否相同等等
    - 1.5.1.3 C++中String类，std::string是C++标准库中提供的字符串类，它提供了许多方便的方法和操作符来处理字符串。它方便地进行字符串的操作和管理，而无需手动处理内存分配和释放。
    - 1.5.1.4 输入字符串，cin.getline() 是在输入一段字符完成后开始读取数据。
- 1.5.2 字符串转化
    - 1.5.2.1 字符串转化为数组
    - 1.5.2.2 字符串转化为vector向量
    - 1.5.2.3 将基础类型数据转为字符串





### 02.第二天：运算符和表达式

#### 2.17 运算符和表达式练习题
3.5.1 求1~10的累加和 56
3.5.2 求一个整数任意次方后的最后三位数 56
3.5.3 婚礼上的谎言 57
3.5.4 阿姆斯特朗数 58
3.5.5 满足abcd=(ab+cd) 2的数 59
3.5.6 最大公约数及最小公倍数 59




### 03.第三天：判断和循环
#### 3.1 条件判断
- 3.1.1 条件判断语句
    - 3.1.1.1 if语句
    - 3.1.1.2 if...else语句
    - 3.1.1.3 嵌套的if-else语句
    - 3.1.1.4 使用条件运算符进行判断
    - 3.1.1.5 switch判断语句


#### 3.2 循环语句
- 3.2.1 循环语句
    - 3.2.1.1 while循环语句
    - 3.2.1.2 do...while循环
    - 3.2.1.3 while与do...while比较
    - 3.2.1.4 for循环语句
- 3.2.2 循环控制
    - 3.2.2.1 控制循环的变量
    - 3.2.2.2 break语句
    - 3.2.2.3 continue语句
    - 3.2.2.4 goto语句


#### 3.3 判断和循环练习题
- 3.3.1 判断和循环练习题
    - 3.3.1.1 小写字母转大写 92
    - 3.3.1.2 百鸡百钱问题 92
    - 3.3.1.3 判断三角形类型 93
    - 3.3.1.4 简单计算器 94
    - 3.3.1.5 求总数问题 95
    - 3.3.1.6 加油站加油 96
    - 3.3.1.7 灯塔数量 97
    - 3.3.1.8 尼科彻斯定理 98



### 04.第四天：数组和容器
#### 4.1 数组介绍使用
- 4.1.1 数组基础使用
    - 4.1.1.1 声明数组，在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量
    - 4.1.1.2 初始化数组，可以逐个初始化数组，也可以使用一个初始化语句
    - 4.1.1.3 访问数组元素，数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。
- 4.1.2 C++中数组详解
    - 4.1.2.1 多维数组，C++ 支持多维数组。多维数组最简单的形式是二维数组。
    - 4.1.2.2 指向数组的指针，您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。
    - 4.1.2.3 传递数组给函数，您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。
    - 4.1.2.4 从函数返回数组，C++ 允许从函数返回数组。


#### 4.2 Vector向量
- 4.2.1 Vector向量使用
    - 4.2.1.1 为什么有Vector，C++ 中的 vector 是一种序列容器，它允许你在运行时动态地插入和删除元素。基于数组的数据结构，但它可以自动管理内存
    - 4.2.1.2 Vector基础函数，添加元素，访问元素，获取大小，迭代访问，删除元素，清空 Vector
    - 4.2.1.3 Vector综合实践，创建了一个整数向量，添加了几个元素，然后输出了向量内容、元素的访问、向量的大小等信息，并输出删除元素后的向量。


#### 4.3 容器使用介绍





### 05.第五天：指针和引用
#### 5.1 指针和引用
- 5.1.1 指针的基础介绍
    - 5.1.1.1 什么是指针，通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。
    - 5.1.1.2 指针运算符和取地址运算符，
    - 5.1.1.3 变量与指针，
    - 5.1.1.4 指针运算，
    - 5.1.1.5 左值与右值，
- 5.1.2 引用基础介绍
    - 5.1.2.1 引用的概述，
    - 5.1.2.2 C++ 中创建引用，
    - 5.1.2.3 把引用作为参数，
    - 5.1.2.4 把引用作为返回值，



#### 5.2 指针与数组
8.2.1 数组的存储 180
8.2.2 指针与一维数组 180
8.2.3 指针与二维数组 182
8.2.4 指针与字符数组 186



#### 5.3 指针与安全
8.4.1 内存的分配方式 188
8.4.2 内存安全 190



#### 5.6 函数与引用
8.5.1 左值与右值 193
8.5.2 引用的概述 194
8.5.3 右值引用 195
8.6.1 使用引用传递参数 196
8.6.2 指针与引用 197
8.6.3 右值引用传递参数 199



#### 5.9 指针和引用练习题
8.7.1 使用左值引用实现整数排序 200
8.7.2 查找成绩不及格的学生 201
8.7.3 指针实现冒泡排序 202
8.7.4 使用指针插入元素 203
8.7.5 使用指针的指针输出字符串 204
8.7.6 为二维数组动态分配内存并释放 205
8.7.7 使用右值引用转换二进制为十进制 206



### 06.第六天：函数实践
#### 6.1 函数的定义
7.2.1 无参函数 142
7.2.2 有参函数 142
7.2.3 空函数 143

#### 6.2 返回语句
7.3.1 从函数返回 143
7.3.2 返回值 144


#### 6.3 函数参数
7.4.1 形式参数与实际参数 145
7.4.2 数组作函数参数 147
7.4.3 main参数 151


#### 6.4 函数的调用
7.5.1 函数调用方式 153
7.5.2 嵌套调用 153
7.5.3 递归调用 155



#### 6.5 内部和外部函数
7.6.1 内部函数 158
7.6.2 外部函数 158




#### 6.8 数组和容器练习题
6.5.1 相邻元素之和 129
6.5.2 选票系统 130
6.5.3 统计学生成绩 131
6.5.4 模拟比赛打分 132
6.5.5 矩阵的转置 133
6.5.6 设计魔方阵 135
6.5.7 统计各种字符个数 136




### 07.第七天：IO输入和输出
#### 7.1 文件流
13.1.1 C++中的流类库 356
13.1.2 类库的使用 356
13.1.3 ios类中的枚举常量 357
13.1.4 流的输入/输出 357


#### 7.2 文件打开
13.2.1 打开方式 358
13.2.2 默认打开模式 359
13.2.3 打开文件同时创建文件 360



#### 7.3 文件的读写
13.3.1 文件流 361
13.3.2 写文本文件 363
13.3.3 读取文本文件 364
13.3.4 二进制文件的读/写 365
13.3.5 实现文件复制 366


#### 7.4 文件指针移动操作
13.4.1 文件错误与状态 368
13.4.2 文件的追加 368
13.4.3 文件结尾的判断 370
13.4.4 在指定位置读/写文件 371



#### 7.5 文件与流的关联



#### 7.8 IO流实践
13.7.1 合并两个文件信息 375
13.7.2 文件复制 376
13.7.3 文件加密 377
13.7.4 使用销毁的手段保护文件内容 379
13.7.5 在文件中查找关键词出现的次数 380



### 08.第八天：结构和类
#### 8.1 C++数据结构
- 8.1.1 struct结构类型
    - 8.1.1.1 为何设计结构，结构是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。
    - 8.1.1.2 定义结构，使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型
    - 8.1.1.3 访问结构成员，使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。
- 8.1.2 struct结构实践
    - 8.1.2.1 结构作为函数参数，把结构作为函数参数，传参方式与其他类型的变量或指针类似。
    - 8.1.2.2 指向结构的指针，可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似：struct Books *struct_pointer;
    - 8.1.2.3 typedef结构方式，可以为创建的类型取一个"别名"。
    - 8.1.2.4 . 与 -> 运算符，访问结构的成员时使用点运算符，而通过指针访问结构的成员时则使用箭头运算符。
    - 8.1.2.5 结构作为函数返回值，可以在函数中定义返回值为结构，对函数封装



#### 8.2 类和对象
- 8.2.1 类声明和实现
    - 8.2.1.1 类概述，C++ 支持面向对象程序设计。类用于指定对象的形式，是一种用户自定义的数据类型，它是一种封装了数据和函数的组合。
    - 8.2.1.2 类的声明与定义，定义一个类需要使用关键字 class，然后指定类的名称，并类的主体是包含在一对花括号中，主体包含类的成员变量和成员函数。
    - 8.2.1.3 类的实现，定义了一个名为Person的类。它有两个私有成员变量：name和age。我们使用构造函数来初始化这些成员变量。
    - 8.2.1.4 对象的声明，类提供了对象的蓝图，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。
- 8.2.2 构造函数
    - 8.2.2.1 构造函数概述，类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。
    - 8.2.2.2 带参数的构造函数，默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值
    - 8.2.2.3 析构函数，类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。
    - 8.2.2.4 拷贝构造函数，拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。
- 8.2.3 类访问修饰符
    - 8.2.3.1 类访问修饰符介绍，类成员的访问限制是通过在类主体内部对各个区域标记 public、private、protected 来指定的。
    - 8.2.3.2 访问修饰符继承中的特点，有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。



#### 8.3 类成员
- 8.3.1 访问类的属性
    - 8.3.1.1 访问类成员，类的对象的公共数据成员可以使用直接成员访问运算符 . 来访问。
    - 8.3.1.2 成员函数，成员函数可以定义在类定义内部，或者单独使用范围解析运算符 :: 来定义。
    - 8.3.1.3 内联成员函数，在类定义中定义的成员函数把函数声明为内联的，即便没有使用 inline 标识符。
    - 8.3.1.4 友元函数，类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。
    - 8.3.1.5 静态类成员，声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。
- 8.3.2 类成员其他
    - 8.3.2.1 隐藏的this指针，this是一个隐藏的指针，可以在类的成员函数中使用，它可以用来指向调用对象。
    - 8.3.2.2 指向类的指针，指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 ->，就像访问指向结构的指针一样。
    - 8.3.2.2 嵌套类
    - 8.3.2.3 局部类



#### 8.4 命名空间
- 8.4.1 命名空间实现
    - 8.4.1.1 命名空间场景介绍，引入了命名空间这个概念，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。
    - 8.4.1.2 定义命名空间，命名空间的定义使用关键字 namespace，后跟命名空间的名称。为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称
    - 8.4.1.3 using 指令，可以使用 using namespace 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。
    - 8.4.1.4 不连续的命名空间，命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。
    - 8.4.1.5 嵌套的命名空间，命名空间可以嵌套，可以在一个命名空间中定义另一个命名空间。可以通过使用 :: 运算符来访问嵌套的命名空间中的成员







### 09.第九天：继承和派生
#### 9.1 继承
11.1.1 类的继承 278
11.1.2 继承后可访问性 280
11.1.3 构造函数访问顺序 283
11.1.4 子类隐藏父类的成员函数 284



#### 9.2 重载运算符
11.2.1 重载运算符的必要性 288
11.2.2 重载运算符的形式与规则 289
11.2.3 重载运算符的运算 291
11.2.4 转换运算符 293



#### 9.3 多重继承
11.3.1 多重继承定义 295
11.3.2 二义性 296
11.3.3 多重继承的构造顺序 297


#### 9.4 多态
11.4.1 虚函数概述 299
11.4.2 利用虚函数实现动态绑定 299
11.4.3 虚继承 301



#### 9.5 抽象类
11.5.1 纯虚函数 303
11.5.2 实现抽象类中的成员函数 305



### 10.第十天：多线程和并发
- pthread 线程使用
- 



### 11.第十一天：线程安全锁



### 13.第十三天：异常处理
#### 13.1 异常声明和处理
- 13.1.1 异常简单使用
    - 13.1.1.1 异常的介绍，异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：try、catch、throw。
    - 13.1.1.2 抛出异常，可以使用 throw 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式
    - 13.1.1.3 捕获异常，catch 块跟在 try 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。
- 13.1.2 定义新异常
    - 13.1.2.1 C++标准的异常，C++ 提供了一系列标准的异常，定义在 <exception> 中，我们可以在程序中使用这些标准的异常。
    - 13.1.2.2 定义新的异常，可以通过继承和重载 exception 类来定义新的异常。


#### 13.2 异常体系说明
- 13.2.1 异常体系详解
    - 13.2.1.1 std::exception，该异常是所有标准 C++ 异常的父类。
    - 13.2.1.2 std::bad_alloc，该异常可以通过 new 抛出。
    - 13.2.1.3 std::bad_cast，该异常可以通过 dynamic_cast 抛出。
    - 13.2.1.4 std::bad_typeid，该异常可以通过 typeid 抛出。
    - 13.2.1.5 std::bad_exception，这在处理 C++ 程序中无法预期的异常时非常有用。
    - 13.2.1.6 std::logic_error，理论上可以通过读取代码来检测到的异常。
    - 13.2.1.7 std::runtime_error，理论上不可以通过读取代码来检测到的异常。
- 13.2.2 读取代码检测异常
    - 13.2.2.1 std::domain_error，当使用了一个无效的数学域时，会抛出该异常。
    - 13.2.2.2 std::invalid_argument，当使用了无效的参数时，会抛出该异常。
    - 13.2.2.3 std::length_error，当创建了太长的 std::string 时，会抛出该异常。
    - 13.2.2.4 std::out_of_range，该异常可以通过方法抛出，例如 std::vector 和 std::bitset<>::operator[]()。
- 13.2.3 不可通过读取代码检测异常
    - 13.2.3.1 std::overflow_error，当发生数学上溢时，会抛出该异常。
    - 13.2.3.2 std::range_error，当尝试存储超出范围的值时，会抛出该异常。
    - 13.2.3.3 std::underflow_error，当发生数学下溢时，会抛出该异常。






#### 13.3 异常捕获设计
- 13.3.1 异常捕获原理



### 14.第十四天：STL标准模板库


### 18.第十八天：程序调试
17.1 选择正确的调试方法 472
17.2 程序错误常见的4种类型 472
17.2.1 语法错误 472
17.2.2 连接错误 473
17.2.3 运行时错误 473
17.2.4 逻辑错误 474
17.3 调试工具的使用 475
17.3.1 创建调试程序 475
17.3.2 进入调试状态 476
17.3.3 监视窗口 477
17.3.4 调用堆栈窗口 477
17.3.5 内存窗口 478
17.3.6 变量窗口 478
17.3.7 寄存器窗口 478
17.3.8 反汇编窗口 479
17.4 调试的基本应用 479
17.4.1 变量的跟踪与查看 479
17.4.2 位置断点的使用 480


### 19.第十九天：网络通信
#### 19.1 TCP/IP协议
19.1.1 OSI参考模型 506
19.1.2 TCP/IP参考模型 506
19.1.3 IP地址 507
19.1.4 数据包格式 508


#### 19.2 套接字
19.2.1 Winsocket套接字 510
19.2.2 Winsocket的使用 510
19.2.3 套接字阻塞模式 515
19.2.4 字节顺序 515
19.2.5 面向连接流 516
19.2.6 面向无连接流 516


#### 19.3 简单协议通信




## 参考：
- https://coding.imooc.com/class/chapter/414.html#Anchor
- http://gz.mobiletrain.org/sem/xk/wlw/c1.html?quanguo=wlwbdtg=45413543-404-visitB20231025016613&jzl_kwd=762108459412&jzl_ctv=83855904859&jzl_ch=11&jzl_act=45413543&jzl_cpg=388370563&jzl_adp=9090237784&jzl_sty=16&jzl_dv=1&bd_vid=7298289407111102475






